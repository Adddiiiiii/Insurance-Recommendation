{"ast":null,"code":"/**\r\n * Fetches and parses CSV data from a file\r\n * @param {string} filePath - Path to the CSV file\r\n * @returns {Promise<Array>} - Promise that resolves to an array of objects\r\n */\nexport const fetchCsvData = async filePath => {\n  try {\n    const response = await fetch(filePath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch CSV: ${response.status}`);\n    }\n    const csvText = await response.text();\n    return parseCsv(csvText);\n  } catch (error) {\n    console.error('Error fetching CSV data:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Parses CSV text into an array of objects\r\n * @param {string} csvText - CSV text content\r\n * @returns {Array} - Array of objects representing CSV rows\r\n */\nconst parseCsv = csvText => {\n  // Split the CSV text into lines\n  const lines = csvText.split('\\n');\n\n  // Extract headers from the first line\n  const headers = lines[0].split(',').map(header =>\n  // Remove quotes if present\n  header.replace(/^\"(.*)\"$/, '$1'));\n\n  // Process each data row\n  return lines.slice(1).filter(line => line.trim() !== '') // Skip empty lines\n  .map(line => {\n    const values = parseCSVLine(line);\n\n    // Create an object mapping headers to values\n    const row = {};\n    headers.forEach((header, index) => {\n      let value = values[index];\n\n      // Handle numeric values\n      if (/^\\d+$/.test(value)) {\n        value = parseInt(value, 10);\n      } else if (/^\\d+\\.\\d+$/.test(value)) {\n        value = parseFloat(value);\n      }\n      // Handle arrays (comma-separated values within quotes)\n      else if ((header === 'suitableFor' || header === 'risk') && value) {\n        // Clean up array format by removing square brackets and single quotes\n        value = value.replace(/^\\['|'\\]$|'\\s*,\\s*'/g, '') // Remove ['...'] format\n        .replace(/\\[|\\]|'|\"/g, '') // Remove any remaining brackets or quotes\n        .split(',').map(item => item.trim()).filter(item => item !== '');\n      }\n      row[header] = value;\n    });\n    return row;\n  });\n};\n\n/**\r\n * Parse a CSV line, handling quoted values that may contain commas\r\n * @param {string} line - A single line from CSV\r\n * @returns {Array} - Array of values\r\n */\nconst parseCSVLine = line => {\n  const values = [];\n  let currentValue = '';\n  let insideQuotes = false;\n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    if (char === '\"') {\n      insideQuotes = !insideQuotes;\n    } else if (char === ',' && !insideQuotes) {\n      values.push(currentValue.replace(/^\"(.*)\"$/, '$1').trim());\n      currentValue = '';\n    } else {\n      currentValue += char;\n    }\n  }\n\n  // Add the last value\n  if (currentValue) {\n    values.push(currentValue.replace(/^\"(.*)\"$/, '$1').trim());\n  }\n  return values;\n};\n\n/**\r\n * Loads insurance products from CSV\r\n * @returns {Promise<Array>} - Promise that resolves to an array of insurance products\r\n */\nexport const loadInsuranceProducts = async () => {\n  try {\n    const products = await fetchCsvData('/data/insurance_products.csv');\n    return products;\n  } catch (error) {\n    console.error('Error loading insurance products:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["fetchCsvData","filePath","response","fetch","ok","Error","status","csvText","text","parseCsv","error","console","lines","split","headers","map","header","replace","slice","filter","line","trim","values","parseCSVLine","row","forEach","index","value","test","parseInt","parseFloat","item","currentValue","insideQuotes","i","length","char","push","loadInsuranceProducts","products"],"sources":["C:/Users/adity/OneDrive/Documents/AI/Insurance Recommendation Agent/src/utils/csvDataLoader.js"],"sourcesContent":["/**\r\n * Fetches and parses CSV data from a file\r\n * @param {string} filePath - Path to the CSV file\r\n * @returns {Promise<Array>} - Promise that resolves to an array of objects\r\n */\r\nexport const fetchCsvData = async (filePath) => {\r\n  try {\r\n    const response = await fetch(filePath);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch CSV: ${response.status}`);\r\n    }\r\n    \r\n    const csvText = await response.text();\r\n    return parseCsv(csvText);\r\n  } catch (error) {\r\n    console.error('Error fetching CSV data:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Parses CSV text into an array of objects\r\n * @param {string} csvText - CSV text content\r\n * @returns {Array} - Array of objects representing CSV rows\r\n */\r\nconst parseCsv = (csvText) => {\r\n  // Split the CSV text into lines\r\n  const lines = csvText.split('\\n');\r\n  \r\n  // Extract headers from the first line\r\n  const headers = lines[0].split(',').map(header => \r\n    // Remove quotes if present\r\n    header.replace(/^\"(.*)\"$/, '$1')\r\n  );\r\n  \r\n  // Process each data row\r\n  return lines.slice(1)\r\n    .filter(line => line.trim() !== '') // Skip empty lines\r\n    .map(line => {\r\n      const values = parseCSVLine(line);\r\n      \r\n      // Create an object mapping headers to values\r\n      const row = {};\r\n      headers.forEach((header, index) => {\r\n        let value = values[index];\r\n        \r\n        // Handle numeric values\r\n        if (/^\\d+$/.test(value)) {\r\n          value = parseInt(value, 10);\r\n        } else if (/^\\d+\\.\\d+$/.test(value)) {\r\n          value = parseFloat(value);\r\n        } \r\n        // Handle arrays (comma-separated values within quotes)\r\n        else if ((header === 'suitableFor' || header === 'risk') && value) {\r\n          // Clean up array format by removing square brackets and single quotes\r\n          value = value.replace(/^\\['|'\\]$|'\\s*,\\s*'/g, '')  // Remove ['...'] format\r\n                       .replace(/\\[|\\]|'|\"/g, '')           // Remove any remaining brackets or quotes\r\n                       .split(',')\r\n                       .map(item => item.trim())\r\n                       .filter(item => item !== '');\r\n        }\r\n        \r\n        row[header] = value;\r\n      });\r\n      \r\n      return row;\r\n    });\r\n};\r\n\r\n/**\r\n * Parse a CSV line, handling quoted values that may contain commas\r\n * @param {string} line - A single line from CSV\r\n * @returns {Array} - Array of values\r\n */\r\nconst parseCSVLine = (line) => {\r\n  const values = [];\r\n  let currentValue = '';\r\n  let insideQuotes = false;\r\n  \r\n  for (let i = 0; i < line.length; i++) {\r\n    const char = line[i];\r\n    \r\n    if (char === '\"') {\r\n      insideQuotes = !insideQuotes;\r\n    } else if (char === ',' && !insideQuotes) {\r\n      values.push(currentValue.replace(/^\"(.*)\"$/, '$1').trim());\r\n      currentValue = '';\r\n    } else {\r\n      currentValue += char;\r\n    }\r\n  }\r\n  \r\n  // Add the last value\r\n  if (currentValue) {\r\n    values.push(currentValue.replace(/^\"(.*)\"$/, '$1').trim());\r\n  }\r\n  \r\n  return values;\r\n};\r\n\r\n/**\r\n * Loads insurance products from CSV\r\n * @returns {Promise<Array>} - Promise that resolves to an array of insurance products\r\n */\r\nexport const loadInsuranceProducts = async () => {\r\n  try {\r\n    const products = await fetchCsvData('/data/insurance_products.csv');\r\n    return products;\r\n  } catch (error) {\r\n    console.error('Error loading insurance products:', error);\r\n    return [];\r\n  }\r\n}; "],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,YAAY,GAAG,MAAOC,QAAQ,IAAK;EAC9C,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,QAAQ,CAAC;IACtC,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,wBAAwBH,QAAQ,CAACI,MAAM,EAAE,CAAC;IAC5D;IAEA,MAAMC,OAAO,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;IACrC,OAAOC,QAAQ,CAACF,OAAO,CAAC;EAC1B,CAAC,CAAC,OAAOG,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;IAChD,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMD,QAAQ,GAAIF,OAAO,IAAK;EAC5B;EACA,MAAMK,KAAK,GAAGL,OAAO,CAACM,KAAK,CAAC,IAAI,CAAC;;EAEjC;EACA,MAAMC,OAAO,GAAGF,KAAK,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAACE,GAAG,CAACC,MAAM;EAC5C;EACAA,MAAM,CAACC,OAAO,CAAC,UAAU,EAAE,IAAI,CACjC,CAAC;;EAED;EACA,OAAOL,KAAK,CAACM,KAAK,CAAC,CAAC,CAAC,CAClBC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;EAAA,CACnCN,GAAG,CAACK,IAAI,IAAI;IACX,MAAME,MAAM,GAAGC,YAAY,CAACH,IAAI,CAAC;;IAEjC;IACA,MAAMI,GAAG,GAAG,CAAC,CAAC;IACdV,OAAO,CAACW,OAAO,CAAC,CAACT,MAAM,EAAEU,KAAK,KAAK;MACjC,IAAIC,KAAK,GAAGL,MAAM,CAACI,KAAK,CAAC;;MAEzB;MACA,IAAI,OAAO,CAACE,IAAI,CAACD,KAAK,CAAC,EAAE;QACvBA,KAAK,GAAGE,QAAQ,CAACF,KAAK,EAAE,EAAE,CAAC;MAC7B,CAAC,MAAM,IAAI,YAAY,CAACC,IAAI,CAACD,KAAK,CAAC,EAAE;QACnCA,KAAK,GAAGG,UAAU,CAACH,KAAK,CAAC;MAC3B;MACA;MAAA,KACK,IAAI,CAACX,MAAM,KAAK,aAAa,IAAIA,MAAM,KAAK,MAAM,KAAKW,KAAK,EAAE;QACjE;QACAA,KAAK,GAAGA,KAAK,CAACV,OAAO,CAAC,sBAAsB,EAAE,EAAE,CAAC,CAAE;QAAA,CACrCA,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAW;QAAA,CACpCJ,KAAK,CAAC,GAAG,CAAC,CACVE,GAAG,CAACgB,IAAI,IAAIA,IAAI,CAACV,IAAI,CAAC,CAAC,CAAC,CACxBF,MAAM,CAACY,IAAI,IAAIA,IAAI,KAAK,EAAE,CAAC;MAC3C;MAEAP,GAAG,CAACR,MAAM,CAAC,GAAGW,KAAK;IACrB,CAAC,CAAC;IAEF,OAAOH,GAAG;EACZ,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMD,YAAY,GAAIH,IAAI,IAAK;EAC7B,MAAME,MAAM,GAAG,EAAE;EACjB,IAAIU,YAAY,GAAG,EAAE;EACrB,IAAIC,YAAY,GAAG,KAAK;EAExB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACe,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,MAAME,IAAI,GAAGhB,IAAI,CAACc,CAAC,CAAC;IAEpB,IAAIE,IAAI,KAAK,GAAG,EAAE;MAChBH,YAAY,GAAG,CAACA,YAAY;IAC9B,CAAC,MAAM,IAAIG,IAAI,KAAK,GAAG,IAAI,CAACH,YAAY,EAAE;MACxCX,MAAM,CAACe,IAAI,CAACL,YAAY,CAACf,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;MAC1DW,YAAY,GAAG,EAAE;IACnB,CAAC,MAAM;MACLA,YAAY,IAAII,IAAI;IACtB;EACF;;EAEA;EACA,IAAIJ,YAAY,EAAE;IAChBV,MAAM,CAACe,IAAI,CAACL,YAAY,CAACf,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;EAC5D;EAEA,OAAOC,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMgB,qBAAqB,GAAG,MAAAA,CAAA,KAAY;EAC/C,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMvC,YAAY,CAAC,8BAA8B,CAAC;IACnE,OAAOuC,QAAQ;EACjB,CAAC,CAAC,OAAO7B,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IACzD,OAAO,EAAE;EACX;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}